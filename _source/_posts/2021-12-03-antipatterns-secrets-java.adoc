---
layout: blog_post
title: "5 Anti-Patterns with Secrets in Java"
author: brian-demers
by: advocate
communities: [security,java]
description: "Learn how how to better manage and protect your passwords and API keys!"
tags: [java, security, secrets, cryptography, tips]
tweets:
- "When was the last time you checked a password into source control? ü§¶ Here are a few tips to avoid that and more‚ÄºÔ∏è"
- "API keys, passwords, and secrets. Learn a few common anti-patterns to avoid ‚ö†Ô∏è"
- "Secrets, passwords, and API keys oh my‚ÄºÔ∏è Make sure you are handling them correctly üßë‚Äçüíª"
image:
type: awareness
---

:toc: macro
:page-liquid:
:experimental:

Most applications use some secret or password: database connection info, API keys, OAuth client secrets, JWT keys, etc. Dealing with these secrets in your projects is always a chore, and it's commonly done wrong. In this post, I'll explain a few common problems and offer suggestions to help you avoid these issues.

toc::[]

== 1. Secrets checked into source control

Checking a secret into source control is easy to do, and most of us have done it at one point, even if we don't want to admit it. Once a secret is in your source control, it's in there forever; it only takes https://github.com/search?q=removed+password&type=commits[a quick history search] to find them.

If you find a secret in your source, remove it and revoke it. It's best if secrets never get checked in the first place, watch out for them in code reviews and scan your code bases to ensure this doesn't happen: https://www.gitguardian.com/[GitGuardian] and https://github.com/awslabs/git-secrets[git-secrets].

Secrets often enter source trees by accident, usually because you temporarily typed one into a config file. When secrets are mixed in with other application properties, it makes them harder to spot or simply forgotten about. Keep secrets out of your source entirely by using an https://12factor.net/config[external configuration] provider like Hashicorp Vault, using environmental variables], or by keeping secrets in a separate file outside of your source tree (or one that is explicitly ignored in your `.gitignore` file.)

TIP: Check out the https://github.com/paulschwarz/spring-dotenv[spring-dotenv] to use `.env` files with your Spring projects.


== 2. Confusing encoding with encryption

Many folks are confused about the difference between encoding and encryption; they are very distinct operations and cannot be interchanged.

=== Encoding

Data that is _encoded_ is transformed into another format, usually to make transferring between systems possible. An encoded value may or may not be human-readable, but it needs to be treated the same way as the original input source.  The following examples show a string encoded in two common encoding schemes URL encoding.

URL Encoded:

[source,java]
----
String text = "Can you still read this text?";
String encoded = URLEncoder.encode(text, UTF_8);
// encoded: Can+you+still+read+this+text%3F
String decoded = URLDecoder.decode(encoded, UTF_8);
assertThat(decoded, equalTo(decoded));
----

Base64 encoded (not human-readable):

[source,java]
----
String text = "Can you still read this text?";
String encoded = Base64.getEncoder().encodeToString(text.getBytes(UTF_8));
// encoded: Q2FuIHlvdSBzdGlsbCByZWFkIHRoaXMgdGV4dD8=
String decoded = new String(Base64.getDecoder().decode(encoded.getBytes(UTF_8)));
assertThat(decoded, equalTo(decoded));
----

IMPORTANT: In both cases, the encoded data can easily be reversed, and the encoded string must be treaded the same way as plain text.

=== Encryption

Data that is encrypted can only be read by authorized parties (anyone with the correct cryptographic key). When data is encrypted, the resulting value is indistinguishable from random data. Because of this, encrypted data is often also encoded to make it easier to transport. For example, in the case of JSON Web Encryption (JWE), the JSON payload is encrypted and then bas64 encoded string.

NOTE: Encryption is a complex topic and not suitable for a quick example. If you want to see a follow-up post covering common encryption use cases, leave a comment below!


== 3. Using a String's bytes for a key

Many of us confuse the terms password and secret key. Generally speaking, passwords make poor cryptographic keys. Passwords are often memorable words making them easy to guess.  Even _good_ passwords that are long and randomly generated have less entropy (the measure of the randomness) than a byte array of the same size.

To illustrate this point, think of a password of eight characters (to keep the math simple, limit the characters to displayable ASCII). There are 95 displayable ASCII characters, which means an eight-character password has a total of 95^8^ = 6.6√ó10^15^ possible combinations. An array of bytes doesn't have this displayable character limit; each byte in the array has 256 possibilities, so a byte array of the same size has 256^8^ = 1.8√ó10^19^ total possible combinations!

Instead of getting the bytes directly from a `String`:

[source,java]
----
String secret = "password";
byte[] secretBytes = secret.getBytes(UTF_8);
----

Use a base64 encoded secret and decode the bytes:

[source,java]
----
String secret = "JJsm0MaRPHI="; // 8 random bytes base64 encoded
byte[] secretBytes = Base64.getDecoder().decode(secret.getBytes(UTF_8));
----

[WARNING]
====
.Did you notice that I hardcoded secrets into these examples?
[%collapsible]
=====
image::{% asset_path 'blog/antipatterns-secrets-java/facepalm.gif' %}[alt=Picard facepalm from www.reactiongifs.com/picard-facepalm/,width=400,align=left]
=====
====


== 4. Restrict access to secrets

It's hard to keep secrets, well... secret. Do you know who has access to each secret used by your application? Secrets kept in environment variables can be viewed by anyone who has access to the running process on the system `ps e -ww -p <pid>`, or access to the Docker demean `docker inspect <container>`.  Even "hidden" secrets used by your build server are https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/GitHub-Actions-Secrets-Example-Token-Tutorial[easy to leak]. Most popular CI services will filter build logs of passwords, but it's easy to work around this. For example, this GitHub Actions script adds a space between each character and bypasses the filtering.

{% raw %}
[source,yaml]
----
steps:
- name: Not So Hidden Secret
  run: "echo ${{secrets.TEST_SECRET}} | sed 's/./& /g'"

# output: C a n   y o u   s t i l l   r e a d   t h i s   t e x t ?
----
{% endraw %}

WARNING: I'm not suggesting you do this; doing so may get you fired. Just be aware that it can happen and treat your secrets accordingly.


== 5. Building your own crypto

As the old saying goes, "Don't roll your own crypto." You are probably aware that you shouldn't implement crypto algorithms yourself, but this saying means much more than that. How the output is used and the protocol involved is just as important as the actual algorithm itself. Different algorithms have been designed for different use cases; many protocols or formats are designed with these in mind.

Instead of cobbling together lower-level primitives, use a high-level library.  This suggestion may be obvious for protocols like TLS/HTTPS, but it also applies to _simple_ formats; a lot can go wrong when a link:/blog/2020/12/21/beginners-guide-to-jwt#problems[JWT is parsed without a quality library].


== Bonus: Be ready to rotate your secrets

If history has taught us anything about secrets, it's that they will leak. In the last year there have been a few notable cases of secrets being exposed: https://travis-ci.community/t/security-bulletin/12081[Travis-CI] and https://about.codecov.io/security-update/[Codecov]. After these issues were disclosed, teams scrambled to update secrets that may have been affected, often resulting in broken builds.

IMPORTANT: When people leave your project, any secrets they had access to must be updated.

Be aware of how your project uses secrets, and practice rotating them before the next leak or personal change.


== Learn more about application security

I've covered a few common problems with managing secrets for Java applications in this post. But this barely scratches the surface of application security and secret management. Check out these other posts to learn more:

- link:/blog/2019/12/20/five-tools-improve-java[Five Tools to Improve Your Java Code]
- link:/blog/2021/03/01/oauth-refcard-patterns-antipatterns[OAuth Patterns and Anti-Patterns]
- link:/blog/2020/12/21/beginners-guide-to-jwt[A Beginner's Guide to JWTs]

If you have questions, please leave a comment below. If you liked this tutorial, follow https://twitter.com/oktadev[@oktadev] on Twitter, follow us https://www.linkedin.com/company/oktadev/[on LinkedIn], or subscribe to https://www.youtube.com/c/oktadev[our YouTube channel].
